import { useState, useEffect, useMemo, useCallback, Fragment } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Service, ServiceTemplate, insertServiceSchema } from "@shared/schema";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { formatCurrency, cn } from "@/lib/utils";
import { motion, AnimatePresence } from "framer-motion";
import AppHeader from "@/components/layout/app-header";
import ProviderNavbar from "@/components/layout/provider-navbar";
import { PageTransition } from "@/components/ui/page-transition";

// Components
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Pencil, 
  Plus, 
  Trash2, 
  Loader2, 
  Timer, 
  Clock, 
  Search,
  Filter,
  Tag,
  CheckCircle2,
  XCircle,
  Clock4,
  DollarSign,
  Scissors,
  Box,
  Menu,
} from "lucide-react";
import { BackButton } from "@/components/ui/back-button";
import { ExecutionTimeDialog } from "@/components/execution-time-dialog";

// Service form schema
const serviceFormSchema = insertServiceSchema.extend({
  id: z.number().optional(),
  nicheId: z.number().optional(), // Campo para selecionar nicho
  templateId: z.number().optional(), // Campo para selecionar serviço pré-cadastrado
});

// Service form values type
type ServiceFormValues = z.infer<typeof serviceFormSchema>;

export default function ServicesPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [serviceToEdit, setServiceToEdit] = useState<Service | null>(null);
  const [serviceToDelete, setServiceToDelete] = useState<Service | null>(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isExecutionTimeDialogOpen, setIsExecutionTimeDialogOpen] = useState(false);
  const [serviceToCustomize, setServiceToCustomize] = useState<Service | null>(null);
  
  // Estados para filtros e visualização
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<number | null>(null);
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [activeTab, setActiveTab] = useState<"all" | "active" | "inactive">("all");
  
  // Estados para armazenar as seleções hierárquicas
  const [selectedNicheId, setSelectedNicheId] = useState<number | null>(null);
  const [selectedTemplateId, setSelectedTemplateId] = useState<number | null>(null);

  // Initialize the form
  const form = useForm<ServiceFormValues>({
    resolver: zodResolver(serviceFormSchema),
    defaultValues: {
      name: "",
      description: "",
      price: 0,
      duration: 30,
      isActive: true,
      categoryId: 0,
      providerId: user?.id || 0,
      nicheId: undefined,
      templateId: undefined
    },
  });

  // Fetch services for this provider using the correct provider-services endpoint
  const {
    data: services = [],
    isLoading: isLoadingServices,
    isError: isServicesError,
  } = useQuery<Service[]>({
    queryKey: [`/api/provider-services/provider/${user?.id}`],
    enabled: !!user?.id,
  });

  // Fetch all categories with niche information
  const {
    data: categories = [],
    isLoading: isLoadingCategories,
    isError: isCategoriesError,
  } = useQuery<any[]>({
    queryKey: ["/api/categories?includeNicheInfo=true"],
  });
  
  // Fetch service templates
  const {
    data: serviceTemplates = [],
    isLoading: isLoadingTemplates,
    isError: isTemplatesError
  } = useQuery<ServiceTemplate[]>({
    queryKey: ["/api/service-templates"],
  });
  
  // Fetch provider services (tempos de execução personalizados)
  const {
    data: providerServices = [],
    isLoading: isLoadingProviderServices
  } = useQuery<any[]>({
    queryKey: [`/api/provider-services/provider/${user?.id}`],
    enabled: !!user?.id,
  });
  
  // Função para obter o tempo de execução personalizado de um serviço
  const getCustomServiceDuration = useCallback(
    (serviceId: number): number | null => {
      if (!providerServices) return null;
      
      const customService = providerServices.find(
        (ps) => ps.serviceId === serviceId
      );
      
      return customService ? customService.executionTime : null;
    },
    [providerServices]
  );

  // Organizar nichos para seleção
  const niches = useMemo(() => {
    const uniqueNiches: { id: number; name: string; }[] = [];
    const nicheIds = new Set<number>();
    
    categories.forEach(category => {
      if (!nicheIds.has(category.nicheId) && category.nicheName) {
        nicheIds.add(category.nicheId);
        uniqueNiches.push({
          id: category.nicheId,
          name: category.nicheName
        });
      }
    });
    
    return uniqueNiches.sort((a, b) => a.name.localeCompare(b.name));
  }, [categories]);
  
  // Filtrar categorias pelo nicho selecionado
  const filteredCategories = useMemo(() => {
    if (!selectedNicheId) return [];
    return categories.filter(category => category.nicheId === selectedNicheId);
  }, [categories, selectedNicheId]);
  
  // Filtrar templates pela categoria selecionada
  const filteredTemplates = useMemo(() => {
    const categoryId = form.watch("categoryId");
    if (!categoryId) return [];
    return serviceTemplates.filter(template => template.categoryId === categoryId);
  }, [serviceTemplates, form.watch("categoryId")]);

  // Create/Update service mutation
  const serviceFormMutation = useMutation({
    mutationFn: async (data: ServiceFormValues) => {
      const response = await apiRequest(
        data.id ? "PUT" : "POST",
        data.id ? `/api/services/${data.id}` : "/api/services",
        data
      );
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Falha ao salvar o serviço");
      }
      
      return response.json();
    },
    onSuccess: () => {
      // Invalidar ambas as consultas para garantir que os dados estejam atualizados
      queryClient.invalidateQueries({ queryKey: [`/api/provider-services/provider/${user?.id}`] });
      queryClient.invalidateQueries({ queryKey: [`/api/services?providerId=${user?.id}`] });
      setIsDialogOpen(false);
      toast({
        title: serviceToEdit ? "Serviço atualizado" : "Serviço adicionado",
        description: serviceToEdit 
          ? "O serviço foi atualizado com sucesso" 
          : "O serviço foi adicionado com sucesso ao seu catálogo",
      });
      resetForm();
    },
    onError: (error: Error) => {
      toast({
        title: "Erro",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete service mutation
  const deleteServiceMutation = useMutation({
    mutationFn: async (serviceId: number) => {
      // Usar a rota correta para excluir serviços de prestador
      const response = await apiRequest("DELETE", `/api/provider-services/${serviceId}`);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Falha ao excluir o serviço");
      }
      
      return true;
    },
    onSuccess: () => {
      // Invalidar as consultas corretas após a exclusão
      queryClient.invalidateQueries({ queryKey: [`/api/provider-services/provider/${user?.id}`] });
      setIsDeleteDialogOpen(false);
      setServiceToDelete(null);
      toast({
        title: "Serviço excluído",
        description: "O serviço foi excluído com sucesso",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Reset form and selection states
  const resetForm = () => {
    form.reset({
      name: "",
      description: "",
      price: 0,
      duration: 30,
      isActive: true,
      categoryId: 0,
      providerId: user?.id || 0,
      nicheId: undefined,
      templateId: undefined
    });
    setSelectedNicheId(null);
    setSelectedTemplateId(null);
    setServiceToEdit(null);
  };

  // Efeito para atualizar o formulário quando o serviço a editar muda
  useEffect(() => {
    if (serviceToEdit) {
      // Encontrar a categoria do serviço para determinar o nicho
      const serviceCategory = categories.find(cat => cat.id === serviceToEdit.categoryId);
      
      form.reset({
        id: serviceToEdit.id,
        name: serviceToEdit.name,
        description: serviceToEdit.description || "",
        price: serviceToEdit.price,
        duration: serviceToEdit.duration,
        isActive: serviceToEdit.isActive === null ? true : serviceToEdit.isActive,
        categoryId: serviceToEdit.categoryId,
        providerId: user?.id || 0,
        nicheId: serviceCategory?.nicheId
      });
      
      if (serviceCategory?.nicheId) {
        setSelectedNicheId(serviceCategory.nicheId);
      }
    }
  }, [serviceToEdit, form, user, categories]);

  // Efeito para atualizar o formulário quando um template é selecionado
  useEffect(() => {
    const templateId = form.watch("templateId");
    if (templateId) {
      const selectedTemplate = serviceTemplates.find(t => t.id === templateId);
      if (selectedTemplate) {
        form.setValue("name", selectedTemplate.name);
        form.setValue("description", selectedTemplate.description || "");
        form.setValue("duration", selectedTemplate.duration);
      }
    }
  }, [form.watch("templateId"), serviceTemplates, form]);

  // Handle form submission
  const onSubmit = (data: ServiceFormValues) => {
    // Validações de preenchimento
    if (!data.templateId && !serviceToEdit) {
      toast({
        title: "Serviço não selecionado",
        description: "Por favor, selecione um serviço do catálogo",
        variant: "destructive"
      });
      return;
    }
    
    // O preço já está em centavos através do handler do campo de entrada
    const price = data.price || 0;
    if (price <= 0) {
      toast({
        title: "Preço inválido",
        description: "O preço do serviço deve ser maior que zero",
        variant: "destructive"
      });
      return;
    }

    if (serviceToEdit) {
      // Para edição, enviar id, preço, duração e status
      serviceFormMutation.mutate({
        id: serviceToEdit.id,
        price: data.price,
        isActive: data.isActive,
        duration: data.duration, // Permite a edição da duração
        name: serviceToEdit.name,
        description: serviceToEdit.description || "",
        categoryId: serviceToEdit.categoryId,
        providerId: serviceToEdit.providerId,
      });
    } else {
      // Para um novo serviço, usando o template selecionado
      const selectedTemplate = serviceTemplates.find(t => t.id === data.templateId);
      if (selectedTemplate) {
        serviceFormMutation.mutate({
          name: selectedTemplate.name,
          description: selectedTemplate.description || "",
          duration: data.duration, // Usa a duração definida pelo prestador
          categoryId: selectedTemplate.categoryId,
          price: data.price,
          isActive: data.isActive,
          providerId: user?.id || 0,
        });
      }
    }
  };

  // Handle nicho selection change
  const handleNicheChange = (nicheId: string) => {
    const nicheIdNumber = parseInt(nicheId);
    setSelectedNicheId(nicheIdNumber);
    form.setValue("nicheId", nicheIdNumber);
    form.setValue("categoryId", 0); // Reset categoria
    form.setValue("templateId", undefined); // Reset template
  };

  // Handle categoria selection change
  const handleCategoryChange = (categoryId: string) => {
    const categoryIdNumber = parseInt(categoryId);
    form.setValue("categoryId", categoryIdNumber);
    form.setValue("templateId", undefined); // Reset template
  };

  // Handle template selection change
  const handleTemplateChange = (templateId: string) => {
    const templateIdNumber = parseInt(templateId);
    setSelectedTemplateId(templateIdNumber);
    form.setValue("templateId", templateIdNumber);
    
    // Preencher outros campos com base no template
    const selectedTemplate = serviceTemplates.find(t => t.id === templateIdNumber);
    if (selectedTemplate) {
      form.setValue("name", selectedTemplate.name);
      form.setValue("description", selectedTemplate.description || "");
      form.setValue("duration", selectedTemplate.duration);
    }
  };

  // Handle edit button click
  const handleEditService = (service: Service) => {
    setServiceToEdit(service);
    setIsDialogOpen(true);
  };

  // Handle delete button click
  const handleDeleteService = (service: Service) => {
    setServiceToDelete(service);
    setIsDeleteDialogOpen(true);
  };

  // Handle confirm delete
  const confirmDelete = () => {
    if (serviceToDelete) {
      deleteServiceMutation.mutate(serviceToDelete.id);
    }
  };

  // Get category name by ID
  const getCategoryName = (categoryId: number) => {
    const category = categories.find(cat => cat.id === categoryId);
    return category?.name || "Categoria não encontrada";
  };

  // Get niche name for a category
  const getNicheName = (categoryId: number) => {
    const category = categories.find(cat => cat.id === categoryId);
    if (category?.nicheId) {
      return category.nicheName || "Nicho não encontrado";
    }
    return "Nicho não encontrado";
  };

  // Loading state
  if (isLoadingServices || isLoadingCategories || isLoadingTemplates) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  // Error state
  if (isServicesError || isCategoriesError || isTemplatesError) {
    return (
      <div className="p-4 text-center text-red-500">
        Ocorreu um erro ao carregar os dados. Por favor, tente novamente.
      </div>
    );
  }

  // Filtrar serviços com base na busca e filtros selecionados
  const filteredServices = useMemo(() => {
    if (!services || services.length === 0) return [];
    
    // Primeiro, converter os serviços para o formato esperado se for necessário
    let formattedServices = services.map(service => {
      // Verificar se estamos lidando com um serviço formatado pelo providerServices endpoint
      if ('serviceName' in service) {
        return {
          id: service.id,
          name: service.serviceName,
          description: service.serviceDescription || '',
          price: service.defaultPrice || 0,
          duration: service.executionTime || service.defaultDuration || 0,
          isActive: service.isActive,
          categoryId: service.categoryId || 0,
          providerId: service.providerId,
          nicheId: service.nicheId,
          // Adicionar propriedades personalizadas do prestador
          executionTime: service.executionTime,
          breakTime: service.breakTime || 0,
          serviceId: service.serviceId,
          // Flag para marcar como serviço personalizado
          isCustom: true
        };
      }
      // Caso já esteja no formato correto
      return service;
    });
    
    console.log("Serviços formatados:", formattedServices);
    
    let filtered = [...formattedServices];
    
    // Filtrar por termo de busca
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(service => 
        service.name.toLowerCase().includes(query) || 
        (service.description && service.description.toLowerCase().includes(query))
      );
    }
    
    // Filtrar por categoria
    if (selectedCategory) {
      filtered = filtered.filter(service => service.categoryId === selectedCategory);
    }
    
    // Filtrar por status (ativo/inativo)
    if (activeTab !== "all") {
      const isActive = activeTab === "active";
      filtered = filtered.filter(service => {
        const serviceActive = service.isActive === null ? true : service.isActive;
        return serviceActive === isActive;
      });
    }
    
    return filtered;
  }, [services, searchQuery, selectedCategory, activeTab]);
  
  // Agrupar serviços por categoria
  const servicesByCategory = useMemo(() => {
    const grouped: Record<string, Service[]> = {};
    
    filteredServices.forEach(service => {
      const category = getCategoryName(service.categoryId);
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(service);
    });
    
    return grouped;
  }, [filteredServices, getCategoryName]);

  return (
    <div className="min-h-screen bg-background pb-20">
      <AppHeader 
        title="Meus Serviços" 
        showBackButton 
        backUrl="/provider/dashboard"
        userType="provider"
        showMenuIcon
      />

      <PageTransition>
        <div className="container p-4 max-w-7xl mx-auto">
          {/* Cabeçalho com título e botão de adicionar */}
          <motion.div 
            className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
          >
            <div>
              <h1 className="text-2xl font-bold">Serviços do Catálogo</h1>
              <p className="text-muted-foreground">Gerencie os serviços que você oferece aos seus clientes</p>
            </div>
            
            <Button 
              onClick={() => {
                resetForm();
                setIsDialogOpen(true);
              }}
              className="w-full sm:w-auto py-5 text-base"
              size="lg"
            >
              <Plus className="h-5 w-5 mr-2" />
              Adicionar Serviço
            </Button>
          </motion.div>
          
          {/* Barra de busca e filtros */}
          <motion.div
            className="mb-6"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.1 }}
          >
            <Card>
              <CardContent className="p-4">
                <div className="flex flex-col sm:flex-row gap-4">
                  <div className="relative flex-1">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      placeholder="Buscar serviços..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="pl-10"
                    />
                  </div>
                  
                  <div className="flex gap-2">
                    <Select
                      value={selectedCategory?.toString() || ""}
                      onValueChange={(value) => setSelectedCategory(value ? parseInt(value) : null)}
                    >
                      <SelectTrigger className="w-full sm:w-[200px]">
                        <SelectValue placeholder="Todas categorias" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">Todas categorias</SelectItem>
                        {categories.map(cat => (
                          <SelectItem key={cat.id} value={cat.id.toString()}>
                            {cat.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    
                    <Button
                      variant="outline" 
                      size="icon"
                      onClick={() => setViewMode(viewMode === "grid" ? "list" : "grid")}
                      title={viewMode === "grid" ? "Visualizar em lista" : "Visualizar em grade"}
                    >
                      {viewMode === "grid" ? (
                        <Menu className="h-4 w-4" />
                      ) : (
                        <Box className="h-4 w-4" />
                      )}
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
          
          {/* Tabs para filtrar por status */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.2 }}
            className="mb-6"
          >
            <Tabs 
              defaultValue="all" 
              value={activeTab}
              onValueChange={(value) => setActiveTab(value as "all" | "active" | "inactive")}
              className="w-full"
            >
              <TabsList className="grid w-full grid-cols-3 mb-4">
                <TabsTrigger value="all">Todos</TabsTrigger>
                <TabsTrigger value="active">Ativos</TabsTrigger>
                <TabsTrigger value="inactive">Inativos</TabsTrigger>
              </TabsList>
            </Tabs>
          </motion.div>

      {services.length === 0 ? (
        <Card>
          <CardContent className="p-8 text-center">
            <p className="text-lg text-gray-500 mb-4">
              Você ainda não tem nenhum serviço cadastrado
            </p>
            <Button 
              onClick={() => {
                resetForm();
                setIsDialogOpen(true);
              }}
              className="py-5 text-base"
            >
              <Plus className="h-5 w-5 mr-2" />
              Adicionar Serviço
            </Button>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardHeader>
            <CardTitle>Serviços Oferecidos</CardTitle>
            <CardDescription>
              Gerencie os serviços que você oferece aos seus clientes
            </CardDescription>
          </CardHeader>
          <CardContent className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="whitespace-nowrap">Nome</TableHead>
                  <TableHead className="whitespace-nowrap hidden md:table-cell">Nicho</TableHead>
                  <TableHead className="whitespace-nowrap hidden md:table-cell">Categoria</TableHead>
                  <TableHead className="whitespace-nowrap">Duração</TableHead>
                  <TableHead className="whitespace-nowrap">Preço</TableHead>
                  <TableHead className="whitespace-nowrap">Status</TableHead>
                  <TableHead className="text-right whitespace-nowrap">Ações</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {services.map((service: any) => {
                  // Adaptar o formato do serviço vindo do backend para exibição correta
                  const serviceName = 'serviceName' in service ? service.serviceName : service.name;
                  const categoryId = service.categoryId || 0;
                  const duration = 'executionTime' in service ? service.executionTime : service.duration || 0;
                  const price = 'defaultPrice' in service ? service.defaultPrice : service.price || 0;
                  
                  return (
                    <TableRow key={service.id}>
                      <TableCell className="font-medium">{serviceName}</TableCell>
                      <TableCell className="hidden md:table-cell">{getNicheName(categoryId)}</TableCell>
                      <TableCell className="hidden md:table-cell">{getCategoryName(categoryId)}</TableCell>
                      <TableCell>
                        {/* A duração exibida agora reflete o tempo de execução personalizado */}
                        {duration} min
                      </TableCell>
                      <TableCell>{formatCurrency(price)}</TableCell>
                      <TableCell>
                        <Badge variant={service.isActive ? "success" : "secondary"}>
                          {service.isActive ? "Ativo" : "Inativo"}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right space-x-1 whitespace-nowrap">
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => {
                            setServiceToCustomize(service);
                            setIsExecutionTimeDialogOpen(true);
                          }}
                          title="Personalizar tempo de execução"
                          className="hover:bg-amber-50"
                        >
                          <Clock className="h-4 w-4 text-amber-500" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleEditService(service)}
                          title="Editar serviço"
                          className="hover:bg-blue-50 ml-1"
                        >
                          <Pencil className="h-4 w-4 mr-1 text-blue-500" />
                          <span className="hidden sm:inline">Editar</span>
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteService(service)}
                          title="Excluir serviço"
                          className="hover:bg-red-50 ml-1"
                        >
                          <Trash2 className="h-4 w-4 mr-1 text-red-500" />
                          <span className="hidden sm:inline">Excluir</span>
                        </Button>
                      </TableCell>
                    </TableRow>
                  );
                })}
                        variant="ghost"
                        size="icon"
                        onClick={() => {
                          setServiceToCustomize(service);
                          setIsExecutionTimeDialogOpen(true);
                        }}
                        title="Personalizar tempo de execução"
                        className="hover:bg-amber-50"
                      >
                        <Clock className="h-4 w-4 text-amber-500" />
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleEditService(service)}
                        title="Editar serviço"
                        className="hover:bg-blue-50 ml-1"
                      >
                        <Pencil className="h-4 w-4 mr-1 text-blue-500" />
                        <span className="hidden sm:inline">Editar</span>
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteService(service)}
                        title="Excluir serviço"
                        className="hover:bg-red-50 ml-1"
                      >
                        <Trash2 className="h-4 w-4 mr-1 text-red-500" />
                        <span className="hidden sm:inline">Excluir</span>
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      )}

      {/* Service Form Dialog */}
      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="sm:max-w-[95%] md:max-w-[540px] max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              {serviceToEdit ? "Editar Serviço" : "Adicionar Serviço"}
            </DialogTitle>
            <DialogDescription>
              {serviceToEdit 
                ? "Você pode alterar o preço e o status do serviço."
                : "Escolha um nicho, categoria e serviço para adicionar ao seu catálogo."}
            </DialogDescription>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              {/* Seleção hierárquica para novo serviço */}
              {!serviceToEdit && (
                <>
                  {/* Seleção de Nicho */}
                  <FormField
                    control={form.control}
                    name="nicheId"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-base">Nicho</FormLabel>
                        <Select
                          onValueChange={handleNicheChange}
                          value={selectedNicheId?.toString() || ""}
                        >
                          <FormControl>
                            <SelectTrigger className="h-12 text-base">
                              <SelectValue placeholder="Selecione um nicho" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent className="max-h-[300px]">
                            {niches.map((niche) => (
                              <SelectItem key={niche.id} value={niche.id.toString()}>
                                {niche.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormDescription>
                          Primeiro, escolha o nicho do serviço
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {/* Seleção de Categoria (disponível após selecionar nicho) */}
                  {selectedNicheId && (
                    <FormField
                      control={form.control}
                      name="categoryId"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-base">Categoria</FormLabel>
                          <Select
                            onValueChange={handleCategoryChange}
                            value={field.value ? field.value.toString() : ""}
                            disabled={filteredCategories.length === 0}
                          >
                            <FormControl>
                              <SelectTrigger className="h-12 text-base">
                                <SelectValue placeholder="Selecione uma categoria" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="max-h-[300px]">
                              {filteredCategories.length === 0 ? (
                                <SelectItem value="empty" disabled>
                                  Nenhuma categoria disponível para este nicho
                                </SelectItem>
                              ) : (
                                filteredCategories.map((category) => (
                                  <SelectItem key={category.id} value={category.id.toString()}>
                                    {category.name}
                                  </SelectItem>
                                ))
                              )}
                            </SelectContent>
                          </Select>
                          <FormDescription>
                            Agora, escolha a categoria do serviço
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}

                  {/* Seleção de Serviço (disponível após selecionar categoria) */}
                  {form.watch("categoryId") > 0 && (
                    <FormField
                      control={form.control}
                      name="templateId"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-base">Serviço</FormLabel>
                          <Select
                            onValueChange={handleTemplateChange}
                            value={field.value?.toString() || ""}
                            disabled={filteredTemplates.length === 0}
                          >
                            <FormControl>
                              <SelectTrigger className="h-12 text-base">
                                <SelectValue placeholder="Selecione um serviço" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="max-h-[300px]">
                              {filteredTemplates.length === 0 ? (
                                <SelectItem value="empty" disabled>
                                  Nenhum serviço disponível para esta categoria
                                </SelectItem>
                              ) : (
                                filteredTemplates.map((template) => (
                                  <SelectItem key={template.id} value={template.id.toString()}>
                                    {template.name}
                                  </SelectItem>
                                ))
                              )}
                            </SelectContent>
                          </Select>
                          <FormDescription>
                            Por fim, escolha o serviço que deseja oferecer
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}
                </>
              )}

              {/* Campos de visualização do serviço selecionado */}
              {(form.watch("templateId") || serviceToEdit) && (
                <>
                  <div className="grid grid-cols-1 gap-4">
                    {/* Nome do serviço (somente leitura) */}
                    <FormField
                      control={form.control}
                      name="name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-base">Nome do Serviço</FormLabel>
                          <Input 
                            value={field.value} 
                            disabled
                            className="bg-gray-100 h-12 text-base"
                          />
                          <FormDescription className="text-xs text-muted-foreground">
                            O nome do serviço é definido pelo administrador
                          </FormDescription>
                        </FormItem>
                      )}
                    />

                    {/* Duração do serviço (editável pelo prestador) */}
                    <FormField
                      control={form.control}
                      name="duration"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-base">Duração (minutos)</FormLabel>
                          <FormControl>
                            <Input 
                              type="number"
                              min="5"
                              step="5" 
                              className="h-12 text-base"
                              placeholder="30"
                              {...field}
                            />
                          </FormControl>
                          <FormDescription className="text-xs text-muted-foreground">
                            Defina o tempo de duração do serviço em minutos
                          </FormDescription>
                        </FormItem>
                      )}
                    />

                    {/* Descrição do serviço (somente leitura) */}
                    <FormField
                      control={form.control}
                      name="description"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-base">Descrição</FormLabel>
                          <div className="p-3 border rounded-md bg-gray-100 min-h-[100px] text-base">
                            {field.value || "Sem descrição disponível."}
                          </div>
                          <FormDescription className="text-xs text-muted-foreground">
                            A descrição do serviço é definida pelo administrador
                          </FormDescription>
                        </FormItem>
                      )}
                    />
                  </div>

                  {/* Campo de preço (editável) com formatação automática */}
                  <FormField
                    control={form.control}
                    name="price"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-base">Preço (R$)</FormLabel>
                        <FormControl>
                          <Input
                            type="text"
                            placeholder="R$0,00"
                            onChange={(e) => {
                              // Remove todos os caracteres não numéricos, exceto ponto e vírgula
                              const rawValue = e.target.value.replace(/[^0-9.,]/g, '');
                              // Converte para um número (independente se usa ponto ou vírgula)
                              const numericValue = parseFloat(rawValue.replace(',', '.')) || 0;
                              // Converte para centavos
                              const valueInCents = Math.round(numericValue * 100);
                              field.onChange(valueInCents);
                            }}
                            onBlur={(e) => {
                              // Formata o valor ao sair do campo
                              const valueInReais = typeof field.value === 'number' ? (field.value / 100) : 0;
                              e.target.value = `R$${valueInReais.toFixed(2).replace('.', ',')}`;
                            }}
                            value={typeof field.value === 'number' ? 
                              `R$${(field.value / 100).toFixed(2).replace('.', ',')}` : 
                              'R$0,00'}
                            className="h-12 text-base"
                          />
                        </FormControl>
                        <FormDescription>
                          Defina o valor que você cobra por este serviço
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {/* Status do serviço (editável) */}
                  <FormField
                    control={form.control}
                    name="isActive"
                    render={({ field }) => (
                      <FormItem className="flex flex-row items-center justify-between rounded-md border p-4">
                        <div>
                          <FormLabel className="text-base">Serviço Ativo</FormLabel>
                          <FormDescription>
                            Serviços inativos não aparecem para agendamento
                          </FormDescription>
                        </div>
                        <FormControl>
                          <Switch
                            checked={field.value === true}
                            onCheckedChange={(checked) => field.onChange(checked)}
                            className="scale-125"
                          />
                        </FormControl>
                      </FormItem>
                    )}
                  />
                </>
              )}

              <DialogFooter>
                <Button 
                  type="submit" 
                  disabled={
                    serviceFormMutation.isPending || 
                    (!serviceToEdit && (!form.watch("templateId")))
                  }
                >
                  {serviceFormMutation.isPending && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  {serviceToEdit ? "Atualizar Serviço" : "Adicionar ao Catálogo"}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar exclusão</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o serviço "{serviceToDelete?.name}"?
              Esta ação não pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              disabled={deleteServiceMutation.isPending}
              className="bg-red-500 hover:bg-red-600"
            >
              {deleteServiceMutation.isPending && (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              )}
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Execution Time Dialog */}
      <ExecutionTimeDialog
        isOpen={isExecutionTimeDialogOpen}
        onClose={() => {
          setIsExecutionTimeDialogOpen(false);
          setServiceToCustomize(null);
        }}
        service={serviceToCustomize}
      />
        </div>
      </PageTransition>
      
      <ProviderNavbar />
    </div>
  );
}